<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>playground mk-1</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'Arial', sans-serif;
            background: #f2f2f0;
            color: #000;
            line-height: 1.6;
            position: relative;
            overscroll-behavior: none;
            -webkit-overflow-scrolling: touch;
        }

        /* Film grain texture overlay - FIJO */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.25;
            z-index: 1;
            pointer-events: none;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="400" height="400"><filter id="noise"><feTurbulence type="fractalNoise" baseFrequency="1.2" numOctaves="6" seed="2" /></filter><rect width="100%" height="100%" filter="url(%23noise)" opacity="1"/></svg>');
        }

        /* Subtle vignette */
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            box-shadow: inset 0 0 200px rgba(0,0,0,0.12);
        }

        .header {
            background: #fefefe;
            border-bottom: 1px solid #e0e0e0;
            padding: 1.5rem 2rem;
            position: sticky;
            top: 0;
            z-index: 100;
            overflow: hidden;
        }

        .header::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.12;
            z-index: 1;
            pointer-events: none;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="250" height="250"><filter id="hn"><feTurbulence type="fractalNoise" baseFrequency="1.1" numOctaves="4" /></filter><rect width="100%" height="100%" filter="url(%23hn)"/></svg>');
        }

        .brand {
            font-size: 1rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            text-transform: lowercase;
            position: relative;
            z-index: 2;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem 2rem;
        }

        .hero {
            text-align: center;
            margin-bottom: 2rem;
        }

        .hero h1 {
            font-size: 1.8rem;
            font-weight: 300;
            letter-spacing: -0.02em;
            margin-bottom: 0.5rem;
        }

        .hero p {
            font-size: 0.85rem;
            color: #999;
            font-weight: 300;
            transition: all 0.3s ease;
        }

        .hero .btn,
        .hero .btn-secondary {
            font-size: 0.7rem;
            padding: 0.8rem 1.5rem;
            width: 100%;
        }

        /* Grid Layout */
        .workspace {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .module {
            background: #fefefe;
            border: 1px solid #e0e0e0;
            padding: 1.5rem;
            position: relative;
            overflow: hidden;
            min-width: 0; /* Prevents overflow */
        }

        /* Grain texture on modules - FIJO */
        .module::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.12;
            z-index: 1;
            pointer-events: none;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="300" height="300"><filter id="n"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="5" /></filter><rect width="100%" height="100%" filter="url(%23n)"/></svg>');
        }

        .module > * {
            position: relative;
            z-index: 2;
        }

        .module-full { grid-column: span 12; }
        .module-half { grid-column: span 6; }
        .module-third { grid-column: span 4; }
        .module-twothird { grid-column: span 8; }

        .module-header {
            margin-bottom: 1rem;
            padding-bottom: 0.8rem;
            border-bottom: 1px solid #e0e0e0;
        }

        .module-title {
            font-size: 0.7rem;
            font-weight: 500;
            letter-spacing: 0.08em;
            text-transform: lowercase;
            color: #999;
        }

        .module-desc {
            font-size: 0.65rem;
            font-weight: 400;
            color: #bbb;
            margin-top: 0.3rem;
            line-height: 1.4;
        }

        .module-label {
            font-size: 1.2rem;
            font-weight: 300;
            margin-top: 0.5rem;
        }

        /* Visualizer */
        .visualizer {
            height: 60px;
            background: #fafafa;
            position: relative;
            overflow: hidden;
        }

        .visualizer::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.18;
            z-index: 10;
            pointer-events: none;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="350" height="350"><filter id="vn"><feTurbulence type="fractalNoise" baseFrequency="1.5" numOctaves="7" /></filter><rect width="100%" height="100%" filter="url(%23vn)"/></svg>');
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        /* Pads */
        .pad-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
        }

        .pad {
            aspect-ratio: 1;
            background: #fafafa;
            border: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.15s ease;
            position: relative;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .pad::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.15;
            z-index: 1;
            pointer-events: none;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200"><filter id="pn"><feTurbulence type="fractalNoise" baseFrequency="1.8" numOctaves="4" /></filter><rect width="100%" height="100%" filter="url(%23pn)"/></svg>');
        }

        .pad-label {
            font-size: 0.7rem;
            font-weight: 400;
            text-transform: lowercase;
            letter-spacing: 0.03em;
            color: #666;
            position: relative;
            z-index: 2;
        }

        .pad-key {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            font-size: 0.65rem;
            color: #ccc;
            font-weight: 600;
            z-index: 2;
        }

        .pad:hover {
            background: #f0f0f0;
            border-color: #ccc;
        }

        .pad.active {
            background: #000;
            border-color: #000;
        }

        .pad.active .pad-label {
            color: #fff;
        }

        .pad.active .pad-key {
            color: #666;
        }

        /* Keyboard */
        .keyboard {
            display: flex;
            gap: 1px;
            height: 140px;
            background: #e0e0e0;
            padding: 1px;
            position: relative;
        }

        .key {
            flex: 1;
            background: #fefefe;
            cursor: pointer;
            transition: all 0.05s ease;
            position: relative;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 1rem;
            user-select: none;
            -webkit-user-select: none;
        }

        .key-label {
            font-size: 0.65rem;
            font-weight: 500;
            color: #999;
            text-transform: lowercase;
        }

        .key.black {
            background: #000;
            height: 90px;
            margin: 0 -12px;
            z-index: 2;
            flex: 0.6;
        }

        .key.black .key-label {
            color: #666;
        }

        .key:active, .key.active {
            background: #e0e0e0;
        }

        .key.black:active, .key.black.active {
            background: #333;
        }

        /* Controls */
        .control-group {
            margin-bottom: 1.5rem;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.8rem;
            font-size: 0.7rem;
            font-weight: 400;
            text-transform: lowercase;
            letter-spacing: 0.03em;
            color: #999;
        }

        .control-value {
            color: #000;
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            height: 2px;
            background: #e0e0e0;
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #000;
            border-radius: 50%;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #000;
            border-radius: 50%;
            border: none;
        }

        select {
            width: 100%;
            padding: 0.8rem 1rem;
            background: #fafafa;
            border: 1px solid #e0e0e0;
            font-family: inherit;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L6 6L11 1' stroke='%23666' stroke-width='1.5'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 1rem center;
            padding-right: 2.5rem;
        }

        select:focus {
            outline: none;
            border-color: #999;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 1rem;
            background: #000;
            border: none;
            color: #fff;
            font-family: inherit;
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: lowercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all 0.15s ease;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .btn:hover {
            background: #333;
        }

        .btn:active {
            background: #000;
            transform: scale(0.98);
        }

        .btn-secondary {
            background: #fefefe;
            color: #000;
            border: 1px solid #e0e0e0;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .btn-secondary:hover {
            background: #fafafa;
            border-color: #ccc;
        }

        .btn-secondary.active {
            background: #000;
            color: #fff;
            border-color: #000;
        }

        .slot-btn {
            position: relative;
        }

        .slot-btn.has-content::after {
            content: '';
            position: absolute;
            top: 0.3rem;
            right: 0.3rem;
            width: 5px;
            height: 5px;
            background: #666;
            border-radius: 50%;
        }

        .slot-btn.has-content.active::after {
            background: #fff;
        }

        .btn-group {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        /* Mic indicator */
        .mic-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #999;
            margin-right: 0.5rem;
            transition: all 0.3s ease;
        }

        .mic-indicator.active {
            background: #ff4444;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* Sequencer */
        .sequencer {
            background: #fafafa;
            padding: 0.8rem;
        }

        .seq-row {
            display: grid;
            grid-template-columns: 50px 1fr;
            gap: 6px;
            margin-bottom: 6px;
            align-items: center;
        }

        .seq-row:last-child {
            margin-bottom: 0;
        }

        .seq-label {
            font-size: 0.6rem;
            font-weight: 500;
            text-transform: lowercase;
            color: #999;
            text-align: right;
            padding-right: 6px;
        }

        .seq-steps {
            display: grid;
            grid-template-columns: repeat(16, 1fr);
            gap: 2px;
        }

        .step {
            aspect-ratio: 1;
            background: #fefefe;
            border: 1px solid #e0e0e0;
            cursor: pointer;
            transition: all 0.1s ease;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .step:hover {
            background: #f5f5f5;
        }

        .step.active {
            background: #000;
            border-color: #000;
        }

        .step.playing {
            background: #666;
            border-color: #666;
        }

        /* Status Bar */
        .status-bar {
            background: #fefefe;
            border: 1px solid #e0e0e0;
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.7rem;
            font-weight: 400;
            text-transform: lowercase;
            letter-spacing: 0.03em;
            margin-bottom: 1.5rem;
            position: relative;
            overflow: hidden;
        }

        .status-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.12;
            z-index: 1;
            pointer-events: none;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="250" height="250"><filter id="sn"><feTurbulence type="fractalNoise" baseFrequency="1.3" numOctaves="5" /></filter><rect width="100%" height="100%" filter="url(%23sn)"/></svg>');
        }

        .status-item {
            color: #999;
            position: relative;
            z-index: 2;
        }

        .status-value {
            color: #000;
            margin-left: 0.5rem;
        }

        /* Info */
        .info {
            background: #fefefe;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            margin-top: 3rem;
            position: relative;
            overflow: hidden;
        }

        .info::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.12;
            z-index: 1;
            pointer-events: none;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="300" height="300"><filter id="infon"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="5" /></filter><rect width="100%" height="100%" filter="url(%23infon)"/></svg>');
        }

        .info h3 {
            font-size: 0.7rem;
            font-weight: 500;
            text-transform: lowercase;
            letter-spacing: 0.08em;
            color: #999;
            margin-bottom: 1rem;
            position: relative;
            z-index: 2;
        }

        .shortcuts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
            position: relative;
            z-index: 2;
        }

        .shortcut {
            display: flex;
            gap: 1rem;
            font-size: 0.85rem;
        }

        .shortcut-key {
            background: #fafafa;
            border: 1px solid #e0e0e0;
            padding: 0.3rem 0.6rem;
            font-weight: 500;
            min-width: 50px;
            text-align: center;
            font-size: 0.7rem;
            text-transform: lowercase;
        }

        .shortcut-desc {
            color: #666;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .module-half, .module-third, .module-twothird {
                grid-column: span 12;
            }
        }

        @media (max-width: 768px) {
            /* Header */
            .header {
                padding: 1rem 1.5rem;
            }

            .brand {
                font-size: 0.9rem;
            }

            /* Hero */
            .hero h1 {
                font-size: 1.5rem;
            }

            .hero p {
                font-size: 0.8rem;
            }

            .hero .btn,
            .hero .btn-secondary {
                font-size: 0.65rem;
                padding: 0.7rem 1.2rem;
            }

            /* Container */
            .container {
                padding: 1.5rem 1rem;
            }

            /* Modules */
            .module {
                padding: 1rem;
            }

            .module-header {
                margin-bottom: 0.8rem;
                padding-bottom: 0.6rem;
            }

            .module-title {
                font-size: 0.65rem;
            }

            .module-desc {
                font-size: 0.6rem;
            }

            /* Workspace */
            .workspace {
                gap: 1rem;
                margin-bottom: 1rem;
            }

            /* Drum pads */
            .pad-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 0.8rem;
            }

            .pad-label {
                font-size: 0.65rem;
            }

            .pad-key {
                font-size: 0.6rem;
                top: 0.4rem;
                right: 0.4rem;
            }

            /* Keyboard */
            .keyboard {
                height: 100px;
                overflow-x: auto;
                overflow-y: hidden;
                -webkit-overflow-scrolling: touch;
            }

            .key {
                min-width: 35px;
                padding-bottom: 0.8rem;
            }

            .key.black {
                height: 65px;
                min-width: 25px;
            }

            .key-label {
                font-size: 0.6rem;
            }

            /* Sequencer */
            .sequencer {
                padding: 0.6rem;
            }

            .seq-row {
                grid-template-columns: 40px 1fr;
                gap: 4px;
                margin-bottom: 4px;
            }

            .seq-label {
                font-size: 0.55rem;
                padding-right: 4px;
            }

            .seq-steps {
                gap: 1.5px;
            }

            /* Controls */
            .control-label {
                font-size: 0.65rem;
            }

            .control-group {
                margin-bottom: 1rem;
            }

            /* Buttons */
            .btn, .btn-secondary {
                font-size: 0.7rem;
                padding: 0.8rem;
            }

            .btn-group {
                gap: 0.4rem;
            }

            /* Select */
            select {
                font-size: 0.8rem;
                padding: 0.7rem 0.9rem;
            }

            /* Status bar */
            .status-bar {
                padding: 0.8rem 1rem;
                font-size: 0.65rem;
                flex-wrap: wrap;
                gap: 0.5rem;
            }

            .status-item {
                flex: 1 1 45%;
            }

            /* Visualizer */
            .visualizer {
                height: 50px !important;
            }

            /* Info section */
            .info {
                padding: 1.5rem;
            }

            .shortcuts-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 0.8rem;
            }

            .shortcut {
                font-size: 0.8rem;
            }

            .shortcut-key {
                font-size: 0.65rem;
                padding: 0.25rem 0.5rem;
                min-width: 45px;
            }
        }

        /* Mobile small screens */
        @media (max-width: 480px) {
            /* Header */
            .header {
                padding: 0.8rem 1rem;
            }

            .brand {
                font-size: 0.8rem;
            }

            /* Hero */
            .hero h1 {
                font-size: 1.3rem;
            }

            .hero p {
                font-size: 0.75rem;
            }

            .hero .btn,
            .hero .btn-secondary {
                font-size: 0.6rem;
                padding: 0.65rem 1rem;
            }

            /* Container */
            .container {
                padding: 1rem 0.8rem;
            }

            /* Modules */
            .module {
                padding: 0.8rem;
            }

            /* Drum pads - 2 columns on very small screens */
            .pad-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.6rem;
            }

            /* Keyboard */
            .keyboard {
                height: 90px;
            }

            .key {
                min-width: 30px;
            }

            .key.black {
                height: 60px;
                min-width: 20px;
            }

            /* Sequencer */
            .seq-row {
                grid-template-columns: 35px 1fr;
            }

            .seq-label {
                font-size: 0.5rem;
            }

            /* Status bar */
            .status-bar {
                padding: 0.7rem 0.8rem;
                font-size: 0.6rem;
            }

            /* Slot info */
            .module .btn-group {
                grid-template-columns: repeat(2, 1fr);
            }

            .slot-btn {
                font-size: 0.65rem;
            }

            /* Info section */
            .shortcuts-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Tablet specific */
        @media (min-width: 768px) and (max-width: 1024px) {
            .container {
                padding: 2rem 1.5rem;
            }

            /* Allow some 2-column layouts on tablet */
            .module-half {
                grid-column: span 6;
            }

            /* Drums can stay 2/3 on tablet */
            .workspace:first-of-type .module-twothird {
                grid-column: span 8;
            }

            .workspace:first-of-type .module-third {
                grid-column: span 4;
            }
        }

        /* Touch improvements for all mobile/tablet */
        @media (hover: none) and (pointer: coarse) {
            .pad, .key, .step, .btn, .btn-secondary, .slot-btn {
                -webkit-tap-highlight-color: transparent;
                touch-action: manipulation;
            }

            /* Larger touch targets */
            .pad {
                min-height: 60px;
            }

            .step {
                min-height: 20px;
            }

            input[type="range"] {
                height: 30px;
                padding: 10px 0;
            }

            input[type="range"]::-webkit-slider-thumb {
                width: 20px;
                height: 20px;
            }

            input[type="range"]::-moz-range-thumb {
                width: 20px;
                height: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="brand">playground mk-1</div>
        <div style="font-size: 0.7rem; color: #999; font-weight: 400; margin-top: 0.3rem;" id="timestamp"></div>
    </div>

    <div class="container">
        <div class="hero">
            <h1>create · loop · play</h1>
            <p>press enter to start</p>
            <div style="display: flex; gap: 0.5rem; justify-content: center; margin-top: 1rem;">
                <button class="btn" id="loadDemoBtn" style="max-width: 150px;">load demo</button>
                <button class="btn-secondary" id="clearAllBtn" style="max-width: 150px; padding: 0.8rem 1.5rem; font-size: 0.7rem;">clear all</button>
            </div>
        </div>

        <div class="status-bar">
            <div class="status-item"><span class="status-value" id="sysStatus">ready</span></div>
            <div class="status-item">rec: <span class="status-value" id="recStatus">off</span></div>
            <div class="status-item"><span class="status-value" id="tempoStatus">120</span> bpm</div>
            <div class="status-item">patterns: <span class="status-value" id="patternCount">0</span></div>
        </div>

        <!-- Visualizer - top monitor (full width, thin) -->
        <div class="workspace">
            <div class="module module-full">
                <div class="module-header">
                    <div class="module-title">wave</div>
                    <div class="module-desc">visual audio feedback</div>
                </div>
                <div class="visualizer" style="height: 60px;">
                    <canvas id="viz"></canvas>
                </div>
            </div>
        </div>

        <!-- Main Grid - Drums + Pattern -->
        <div class="workspace">
            <!-- Drums - main instrument -->
            <div class="module module-twothird">
                <div class="module-header">
                    <div class="module-title">drums</div>
                    <div class="module-desc">tap pads or use keys 1-8 to play sounds</div>
                </div>
                <div class="pad-grid">
                    <div class="pad" data-sound="kick">
                        <span class="pad-key">1</span>
                        <span class="pad-label">kick</span>
                    </div>
                    <div class="pad" data-sound="snare">
                        <span class="pad-key">2</span>
                        <span class="pad-label">snare</span>
                    </div>
                    <div class="pad" data-sound="hihat">
                        <span class="pad-key">3</span>
                        <span class="pad-label">hat</span>
                    </div>
                    <div class="pad" data-sound="clap">
                        <span class="pad-key">4</span>
                        <span class="pad-label">clap</span>
                    </div>
                    <div class="pad" data-sound="tom1">
                        <span class="pad-key">5</span>
                        <span class="pad-label">tom</span>
                    </div>
                    <div class="pad" data-sound="perc">
                        <span class="pad-key">6</span>
                        <span class="pad-label">perc</span>
                    </div>
                    <div class="pad" data-sound="cymbal">
                        <span class="pad-key">7</span>
                        <span class="pad-label">cymbal</span>
                    </div>
                    <div class="pad" data-sound="rim">
                        <span class="pad-key">8</span>
                        <span class="pad-label">rim</span>
                    </div>
                </div>
            </div>

            <!-- Pattern - junto a drums -->
            <div class="module module-third">
                <div class="module-header">
                    <div class="module-title">pattern</div>
                    <div class="module-desc">program drum rhythms & press play</div>
                </div>
                <div id="sequencer">
                    <div class="seq-row">
                        <div class="seq-label">kick</div>
                        <div class="seq-steps" data-drum="kick"></div>
                    </div>
                    <div class="seq-row">
                        <div class="seq-label">snare</div>
                        <div class="seq-steps" data-drum="snare"></div>
                    </div>
                    <div class="seq-row">
                        <div class="seq-label">hihat</div>
                        <div class="seq-steps" data-drum="hihat"></div>
                    </div>
                    <div class="seq-row">
                        <div class="seq-label">clap</div>
                        <div class="seq-steps" data-drum="clap"></div>
                    </div>
                    <div class="seq-row">
                        <div class="seq-label">tom</div>
                        <div class="seq-steps" data-drum="tom1"></div>
                    </div>
                    <div class="seq-row">
                        <div class="seq-label">perc</div>
                        <div class="seq-steps" data-drum="perc"></div>
                    </div>
                    <div class="seq-row">
                        <div class="seq-label">cymbal</div>
                        <div class="seq-steps" data-drum="cymbal"></div>
                    </div>
                    <div class="seq-row">
                        <div class="seq-label">rim</div>
                        <div class="seq-steps" data-drum="rim"></div>
                    </div>
                </div>
                <div class="btn-group" style="margin-top: 1rem;">
                    <button class="btn-secondary" id="playSeq">play</button>
                    <button class="btn-secondary" id="clearSeq">clear</button>
                </div>
            </div>
        </div>

        <!-- Keys - full width (more space) -->
        <div class="workspace">
            <div class="module module-full">
                <div class="module-header">
                    <div class="module-title">keys</div>
                    <div class="module-desc">play melodies with a-k keys</div>
                </div>
                
                <div style="margin-bottom: 1.5rem;">
                    <div class="control-label" style="margin-bottom: 0.5rem;">
                        <span>wave</span>
                    </div>
                    <select id="waveType">
                        <option value="sine">sine</option>
                        <option value="square">square</option>
                        <option value="sawtooth">saw</option>
                        <option value="triangle">triangle</option>
                    </select>
                </div>

                <div class="keyboard">
                    <div class="key" data-note="C4"><span class="key-label">a · c4</span></div>
                    <div class="key black" data-note="C#4"><span class="key-label">w</span></div>
                    <div class="key" data-note="D4"><span class="key-label">s · d4</span></div>
                    <div class="key black" data-note="D#4"><span class="key-label">e</span></div>
                    <div class="key" data-note="E4"><span class="key-label">d · e4</span></div>
                    <div class="key" data-note="F4"><span class="key-label">f · f4</span></div>
                    <div class="key black" data-note="F#4"><span class="key-label">t</span></div>
                    <div class="key" data-note="G4"><span class="key-label">g · g4</span></div>
                    <div class="key black" data-note="G#4"><span class="key-label">y</span></div>
                    <div class="key" data-note="A4"><span class="key-label">h · a4</span></div>
                    <div class="key black" data-note="A#4"><span class="key-label">u</span></div>
                    <div class="key" data-note="B4"><span class="key-label">j · b4</span></div>
                    <div class="key" data-note="C5"><span class="key-label">k · c5</span></div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-top: 1.5rem;">
                    <div class="control-group">
                        <div class="control-label">
                            <span>attack</span>
                            <span class="control-value" id="attackVal">10ms</span>
                        </div>
                        <input type="range" id="attack" min="0" max="500" value="10">
                    </div>
                    <div class="control-group">
                        <div class="control-label">
                            <span>release</span>
                            <span class="control-value" id="releaseVal">300ms</span>
                        </div>
                        <input type="range" id="release" min="0" max="2000" value="300">
                    </div>
                </div>
            </div>
        </div>

        <!-- Tempo + FX + Loop (all controls together) -->
        <div class="workspace">
            <div class="module module-third">
                <div class="module-header">
                    <div class="module-title">tempo</div>
                    <div class="module-desc">adjust playback speed</div>
                </div>
                <div class="control-group">
                    <div class="control-label">
                        <span>bpm</span>
                        <span class="control-value" id="tempoVal">120</span>
                    </div>
                    <input type="range" id="tempo" min="60" max="200" value="120">
                </div>
            </div>

            <div class="module module-third">
                <div class="module-header">
                    <div class="module-title">fx</div>
                    <div class="module-desc">add effects to your sound</div>
                </div>
                <div class="control-group">
                    <div class="control-label">
                        <span>reverb</span>
                        <span class="control-value" id="reverbVal">40%</span>
                    </div>
                    <input type="range" id="reverb" min="0" max="100" value="40">
                </div>
                <div class="control-group">
                    <div class="control-label">
                        <span>delay</span>
                        <span class="control-value" id="delayVal">20%</span>
                    </div>
                    <input type="range" id="delay" min="0" max="100" value="20">
                </div>
                <div class="control-group">
                    <div class="control-label">
                        <span>filter</span>
                        <span class="control-value" id="filterVal">8000Hz</span>
                    </div>
                    <input type="range" id="filter" min="100" max="10000" value="8000">
                </div>
            </div>

            <div class="module module-third">
                <div class="module-header">
                    <div class="module-title">loop</div>
                    <div class="module-desc">record & layer up to 4 loops + mic input</div>
                </div>
                
                <!-- Slot selector -->
                <div class="btn-group" style="margin-bottom: 1rem;">
                    <button class="btn-secondary slot-btn active" data-slot="A">A</button>
                    <button class="btn-secondary slot-btn" data-slot="B">B</button>
                    <button class="btn-secondary slot-btn" data-slot="C">C</button>
                    <button class="btn-secondary slot-btn" data-slot="D">D</button>
                </div>
                
                <!-- Mic control -->
                <button class="btn-secondary" id="micBtn" style="margin-bottom: 1rem;">
                    <span class="mic-indicator" id="micIndicator"></span>mic
                </button>
                
                <!-- Slot info -->
                <div style="text-align: center; margin-bottom: 1rem; min-height: 1.2rem;">
                    <span style="font-size: 0.65rem; color: #999;" id="slotInfo">slot A · empty</span>
                </div>
                
                <!-- Controls -->
                <button class="btn-secondary" id="recordBtn">rec</button>
                <button class="btn-secondary" id="overdubBtn" style="margin-top: 0.5rem;">overdub</button>
                <button class="btn-secondary" id="playLoopBtn" style="margin-top: 0.5rem;">play</button>
                <button class="btn-secondary" id="playAllBtn" style="margin-top: 0.5rem;">play all</button>
                <button class="btn-secondary" id="clearLoopBtn" style="margin-top: 0.5rem;">clear</button>
                <button class="btn" id="downloadBtn" style="margin-top: 0.5rem; display: none;">download</button>
                
                <div class="control-group" style="margin-top: 1.5rem;">
                    <div class="control-label">
                        <span>volume</span>
                        <span class="control-value" id="masterVolVal">70%</span>
                    </div>
                    <input type="range" id="masterVol" min="0" max="100" value="70">
                </div>
                <button class="btn" id="initBtn" style="margin-top: 1rem;">start</button>
            </div>
        </div>

                <!-- Info -->
        <div class="info">
            <h3>keys</h3>
            <div class="shortcuts-grid">
                <div class="shortcut">
                    <span class="shortcut-key">1-8</span>
                    <span class="shortcut-desc">drums</span>
                </div>
                <div class="shortcut">
                    <span class="shortcut-key">a-k</span>
                    <span class="shortcut-desc">notes</span>
                </div>
                <div class="shortcut">
                    <span class="shortcut-key">space</span>
                    <span class="shortcut-desc">play/stop</span>
                </div>
                <div class="shortcut">
                    <span class="shortcut-key">enter</span>
                    <span class="shortcut-desc">start</span>
                </div>
                <div class="shortcut">
                    <span class="shortcut-key">load demo</span>
                    <span class="shortcut-desc">example track</span>
                </div>
                <div class="shortcut">
                    <span class="shortcut-key">clear all</span>
                    <span class="shortcut-desc">reset everything</span>
                </div>
                <div class="shortcut">
                    <span class="shortcut-key">r</span>
                    <span class="shortcut-desc">record</span>
                </div>
                <div class="shortcut">
                    <span class="shortcut-key">o</span>
                    <span class="shortcut-desc">overdub</span>
                </div>
                <div class="shortcut">
                    <span class="shortcut-key">p</span>
                    <span class="shortcut-desc">play loop</span>
                </div>
                <div class="shortcut">
                    <span class="shortcut-key">l</span>
                    <span class="shortcut-desc">play all</span>
                </div>
                <div class="shortcut">
                    <span class="shortcut-key">c</span>
                    <span class="shortcut-desc">clear loop</span>
                </div>
                <div class="shortcut">
                    <span class="shortcut-key">v</span>
                    <span class="shortcut-desc">download</span>
                </div>
                <div class="shortcut">
                    <span class="shortcut-key">x</span>
                    <span class="shortcut-desc">clear pattern</span>
                </div>
                <div class="shortcut">
                    <span class="shortcut-key">q/z/b/n</span>
                    <span class="shortcut-desc">slots A/B/C/D</span>
                </div>
                <div class="shortcut">
                    <span class="shortcut-key">m</span>
                    <span class="shortcut-desc">toggle mic</span>
                </div>
            </div>
        </div>

        <!-- Credit -->
        <div style="text-align: center; padding: 2rem; font-size: 0.7rem; color: #999;">
            designed, coded & built by <a href="https://nicolasbronzina.com" target="_blank" style="color: #666; text-decoration: none; border-bottom: 1px solid #e0e0e0;">nicolás bronzina</a>
        </div>
    </div>

    <script>
        // Audio Engine
        let audioContext;
        let masterGain;
        let analyser;
        let isActive = false;
        
        // Microphone system
        let micStream = null;
        let micSource = null;
        let micGain = null;
        let isMicActive = false;
        
        // Loop slots system (inspired by Teenage Engineering)
        let loopSlots = {
            A: { loop: [], audioBlob: null, audioBuffer: null, duration: 0, isPlaying: false },
            B: { loop: [], audioBlob: null, audioBuffer: null, duration: 0, isPlaying: false },
            C: { loop: [], audioBlob: null, audioBuffer: null, duration: 0, isPlaying: false },
            D: { loop: [], audioBlob: null, audioBuffer: null, duration: 0, isPlaying: false }
        };
        let activeSlot = 'A';
        let isRecording = false;
        let recordingStart = 0;
        let isOverdub = false;
        
        // Audio recording
        let mediaRecorder;
        let audioChunks = [];
        let mediaStreamDestination;
        
        let sequencerSteps = {
            kick: Array(16).fill(false),
            snare: Array(16).fill(false),
            hihat: Array(16).fill(false),
            clap: Array(16).fill(false),
            tom1: Array(16).fill(false),
            perc: Array(16).fill(false),
            cymbal: Array(16).fill(false),
            rim: Array(16).fill(false)
        };
        let currentStep = 0;
        let isPlaying = false;
        let sequencerInterval;
        
        let attackTime = 10;
        let releaseTime = 300;
        
        const canvas = document.getElementById('viz');
        const ctx = canvas.getContext('2d');
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        
        const notes = {
            'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13,
            'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'G4': 392.00,
            'G#4': 415.30, 'A4': 440.00, 'A#4': 466.16, 'B4': 493.88,
            'C5': 523.25
        };

        // Init
        function initSystem() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                masterGain = audioContext.createGain();
                masterGain.gain.value = 0.7;
                
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                
                // Create effects chain
                // Delay
                const delayNode = audioContext.createDelay();
                delayNode.delayTime.value = 0.3;
                const delayFeedback = audioContext.createGain();
                delayFeedback.gain.value = 0.3;
                const delayMix = audioContext.createGain();
                delayMix.gain.value = 0.2; // 20% default
                
                // Connect delay feedback loop
                delayNode.connect(delayFeedback);
                delayFeedback.connect(delayNode);
                delayNode.connect(delayMix);
                
                // Reverb (using convolver with impulse response)
                const reverbNode = audioContext.createConvolver();
                const reverbMix = audioContext.createGain();
                reverbMix.gain.value = 0.4; // 40% default
                
                // Create simple reverb impulse response
                const reverbTime = 2;
                const sampleRate = audioContext.sampleRate;
                const length = sampleRate * reverbTime;
                const impulse = audioContext.createBuffer(2, length, sampleRate);
                const impulseL = impulse.getChannelData(0);
                const impulseR = impulse.getChannelData(1);
                
                for (let i = 0; i < length; i++) {
                    const decay = Math.pow(1 - i / length, 2);
                    impulseL[i] = (Math.random() * 2 - 1) * decay;
                    impulseR[i] = (Math.random() * 2 - 1) * decay;
                }
                reverbNode.buffer = impulse;
                reverbNode.connect(reverbMix);
                
                // Filter
                const filterNode = audioContext.createBiquadFilter();
                filterNode.type = 'lowpass';
                filterNode.frequency.value = 8000;
                filterNode.Q.value = 1;
                
                // Connect effects chain
                // masterGain -> delay -> delayMix -> filterNode -> analyser -> destination
                // masterGain -> reverb -> reverbMix -> filterNode
                masterGain.connect(delayNode);
                masterGain.connect(reverbNode);
                masterGain.connect(filterNode);
                delayMix.connect(filterNode);
                reverbMix.connect(filterNode);
                filterNode.connect(analyser);
                analyser.connect(audioContext.destination);
                
                // Store nodes globally for control
                window.delayMix = delayMix;
                window.reverbMix = reverbMix;
                window.filterNode = filterNode;
                
                // Create media stream destination for recording
                mediaStreamDestination = audioContext.createMediaStreamDestination();
                analyser.connect(mediaStreamDestination);
                
                isActive = true;
                document.getElementById('sysStatus').textContent = 'active';
                document.getElementById('initBtn').textContent = 'active';
                document.getElementById('initBtn').classList.add('active');
                
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                drawViz();
            } else if (audioContext.state === 'suspended') {
                audioContext.resume();
                isActive = true;
                document.getElementById('sysStatus').textContent = 'active';
            }
        }

        // Microphone functions
        async function toggleMic() {
            if (!audioContext) {
                initSystem();
                setTimeout(toggleMic, 100);
                return;
            }
            
            if (!isMicActive) {
                // Request microphone access
                try {
                    micStream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        } 
                    });
                    
                    // Create audio source from microphone
                    micSource = audioContext.createMediaStreamSource(micStream);
                    
                    // Create gain node for mic
                    micGain = audioContext.createGain();
                    micGain.gain.value = 1.0;
                    
                    // Connect mic to master gain (goes through effects)
                    micSource.connect(micGain);
                    micGain.connect(masterGain);
                    
                    isMicActive = true;
                    
                    // Update UI
                    document.getElementById('micBtn').classList.add('active');
                    document.getElementById('micIndicator').classList.add('active');
                    
                    // Show message
                    const heroP = document.querySelector('.hero p');
                    const originalText = heroP.textContent;
                    heroP.textContent = 'mic active · ready to capture external audio';
                    setTimeout(() => {
                        heroP.textContent = originalText;
                    }, 3000);
                    
                } catch (error) {
                    console.error('Microphone access denied:', error);
                    alert('Could not access microphone. Please check permissions.');
                }
            } else {
                // Stop microphone
                if (micSource) {
                    micSource.disconnect();
                    micSource = null;
                }
                if (micGain) {
                    micGain.disconnect();
                    micGain = null;
                }
                if (micStream) {
                    micStream.getTracks().forEach(track => track.stop());
                    micStream = null;
                }
                
                isMicActive = false;
                
                // Update UI
                document.getElementById('micBtn').classList.remove('active');
                document.getElementById('micIndicator').classList.remove('active');
                
                // Show message
                const heroP = document.querySelector('.hero p');
                const originalText = heroP.textContent;
                heroP.textContent = 'mic off';
                setTimeout(() => {
                    heroP.textContent = originalText;
                }, 2000);
            }
        }

        // Drums - Enhanced realistic synthesis
        function playDrum(type, skipRecording = false) {
            if (!audioContext) {
                initSystem();
                setTimeout(() => playDrum(type), 100);
                return;
            }
            
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            // Visual feedback
            const pad = document.querySelector(`[data-sound="${type}"]`);
            if (pad) {
                pad.classList.add('active');
                setTimeout(() => pad.classList.remove('active'), 150);
            }
            
            const now = audioContext.currentTime;
            
            switch(type) {
                case 'kick':
                    // Realistic kick: pitch envelope + punch
                    const kickOsc = audioContext.createOscillator();
                    const kickGain = audioContext.createGain();
                    const kickFilter = audioContext.createBiquadFilter();
                    
                    kickOsc.type = 'sine';
                    kickOsc.frequency.setValueAtTime(150, now);
                    kickOsc.frequency.exponentialRampToValueAtTime(40, now + 0.05);
                    kickOsc.frequency.exponentialRampToValueAtTime(20, now + 0.5);
                    
                    kickFilter.type = 'lowpass';
                    kickFilter.frequency.value = 200;
                    kickFilter.Q.value = 1;
                    
                    kickGain.gain.setValueAtTime(1.5, now);
                    kickGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    
                    kickOsc.connect(kickFilter);
                    kickFilter.connect(kickGain);
                    kickGain.connect(masterGain);
                    
                    kickOsc.start(now);
                    kickOsc.stop(now + 0.5);
                    break;
                    
                case 'snare':
                    // Realistic snare: noise + tone
                    const snareOsc = audioContext.createOscillator();
                    const snareNoise = audioContext.createBufferSource();
                    const snareNoiseFilter = audioContext.createBiquadFilter();
                    const snareGain = audioContext.createGain();
                    const snareNoiseGain = audioContext.createGain();
                    
                    // Tone component
                    snareOsc.type = 'triangle';
                    snareOsc.frequency.value = 180;
                    
                    // Noise component
                    const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.2, audioContext.sampleRate);
                    const noiseData = noiseBuffer.getChannelData(0);
                    for (let i = 0; i < noiseBuffer.length; i++) {
                        noiseData[i] = Math.random() * 2 - 1;
                    }
                    snareNoise.buffer = noiseBuffer;
                    
                    snareNoiseFilter.type = 'highpass';
                    snareNoiseFilter.frequency.value = 1000;
                    
                    snareGain.gain.setValueAtTime(0.4, now);
                    snareGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    
                    snareNoiseGain.gain.setValueAtTime(0.8, now);
                    snareNoiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    
                    snareOsc.connect(snareGain);
                    snareNoise.connect(snareNoiseFilter);
                    snareNoiseFilter.connect(snareNoiseGain);
                    snareGain.connect(masterGain);
                    snareNoiseGain.connect(masterGain);
                    
                    snareOsc.start(now);
                    snareOsc.stop(now + 0.2);
                    snareNoise.start(now);
                    snareNoise.stop(now + 0.15);
                    break;
                    
                case 'hihat':
                    // Realistic hi-hat: filtered noise
                    const hihatNoise = audioContext.createBufferSource();
                    const hihatFilter = audioContext.createBiquadFilter();
                    const hihatGain = audioContext.createGain();
                    
                    const hihatBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
                    const hihatData = hihatBuffer.getChannelData(0);
                    for (let i = 0; i < hihatBuffer.length; i++) {
                        hihatData[i] = Math.random() * 2 - 1;
                    }
                    hihatNoise.buffer = hihatBuffer;
                    
                    hihatFilter.type = 'highpass';
                    hihatFilter.frequency.value = 7000;
                    hihatFilter.Q.value = 1;
                    
                    hihatGain.gain.setValueAtTime(0.3, now);
                    hihatGain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                    
                    hihatNoise.connect(hihatFilter);
                    hihatFilter.connect(hihatGain);
                    hihatGain.connect(masterGain);
                    
                    hihatNoise.start(now);
                    break;
                    
                case 'clap':
                    // Realistic clap: multiple noise bursts
                    for (let i = 0; i < 3; i++) {
                        const clapNoise = audioContext.createBufferSource();
                        const clapFilter = audioContext.createBiquadFilter();
                        const clapGain = audioContext.createGain();
                        
                        const clapBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.05, audioContext.sampleRate);
                        const clapData = clapBuffer.getChannelData(0);
                        for (let j = 0; j < clapBuffer.length; j++) {
                            clapData[j] = Math.random() * 2 - 1;
                        }
                        clapNoise.buffer = clapBuffer;
                        
                        clapFilter.type = 'bandpass';
                        clapFilter.frequency.value = 1000;
                        clapFilter.Q.value = 5;
                        
                        const delay = i * 0.015;
                        clapGain.gain.setValueAtTime(0.5, now + delay);
                        clapGain.gain.exponentialRampToValueAtTime(0.01, now + delay + 0.05);
                        
                        clapNoise.connect(clapFilter);
                        clapFilter.connect(clapGain);
                        clapGain.connect(masterGain);
                        
                        clapNoise.start(now + delay);
                    }
                    break;
                    
                case 'tom1':
                    // Realistic tom: pitch envelope + resonance
                    const tomOsc = audioContext.createOscillator();
                    const tomGain = audioContext.createGain();
                    const tomFilter = audioContext.createBiquadFilter();
                    
                    tomOsc.type = 'sine';
                    tomOsc.frequency.setValueAtTime(220, now);
                    tomOsc.frequency.exponentialRampToValueAtTime(150, now + 0.1);
                    
                    tomFilter.type = 'lowpass';
                    tomFilter.frequency.value = 800;
                    tomFilter.Q.value = 8;
                    
                    tomGain.gain.setValueAtTime(1.0, now);
                    tomGain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                    
                    tomOsc.connect(tomFilter);
                    tomFilter.connect(tomGain);
                    tomGain.connect(masterGain);
                    
                    tomOsc.start(now);
                    tomOsc.stop(now + 0.4);
                    break;
                    
                case 'perc':
                    // Realistic perc: metallic tone
                    const percOsc1 = audioContext.createOscillator();
                    const percOsc2 = audioContext.createOscillator();
                    const percGain = audioContext.createGain();
                    
                    percOsc1.type = 'square';
                    percOsc1.frequency.value = 800;
                    percOsc2.type = 'square';
                    percOsc2.frequency.value = 540;
                    
                    percGain.gain.setValueAtTime(0.3, now);
                    percGain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                    
                    percOsc1.connect(percGain);
                    percOsc2.connect(percGain);
                    percGain.connect(masterGain);
                    
                    percOsc1.start(now);
                    percOsc2.start(now);
                    percOsc1.stop(now + 0.08);
                    percOsc2.stop(now + 0.08);
                    break;
                    
                case 'cymbal':
                    // Realistic cymbal: complex filtered noise
                    const cymbalNoise = audioContext.createBufferSource();
                    const cymbalFilter1 = audioContext.createBiquadFilter();
                    const cymbalFilter2 = audioContext.createBiquadFilter();
                    const cymbalGain = audioContext.createGain();
                    
                    const cymbalBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.8, audioContext.sampleRate);
                    const cymbalData = cymbalBuffer.getChannelData(0);
                    for (let i = 0; i < cymbalBuffer.length; i++) {
                        cymbalData[i] = Math.random() * 2 - 1;
                    }
                    cymbalNoise.buffer = cymbalBuffer;
                    
                    cymbalFilter1.type = 'highpass';
                    cymbalFilter1.frequency.value = 5000;
                    cymbalFilter2.type = 'bandpass';
                    cymbalFilter2.frequency.value = 8000;
                    cymbalFilter2.Q.value = 2;
                    
                    cymbalGain.gain.setValueAtTime(0.3, now);
                    cymbalGain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
                    
                    cymbalNoise.connect(cymbalFilter1);
                    cymbalFilter1.connect(cymbalFilter2);
                    cymbalFilter2.connect(cymbalGain);
                    cymbalGain.connect(masterGain);
                    
                    cymbalNoise.start(now);
                    break;
                    
                case 'rim':
                    // Realistic rimshot: short click
                    const rimOsc = audioContext.createOscillator();
                    const rimGain = audioContext.createGain();
                    const rimFilter = audioContext.createBiquadFilter();
                    
                    rimOsc.type = 'square';
                    rimOsc.frequency.value = 1000;
                    
                    rimFilter.type = 'highpass';
                    rimFilter.frequency.value = 2000;
                    
                    rimGain.gain.setValueAtTime(0.5, now);
                    rimGain.gain.exponentialRampToValueAtTime(0.01, now + 0.03);
                    
                    rimOsc.connect(rimFilter);
                    rimFilter.connect(rimGain);
                    rimGain.connect(masterGain);
                    
                    rimOsc.start(now);
                    rimOsc.stop(now + 0.03);
                    break;
            }
            
            if (!skipRecording && (isRecording || isOverdub)) {
                loopSlots[activeSlot].loop.push({
                    type: 'drum',
                    sound: type,
                    time: audioContext.currentTime - recordingStart
                });
            }
        }

        // Synth
        function playNote(freq, skipRecording = false) {
            if (!audioContext) {
                initSystem();
                setTimeout(() => playNote(freq), 100);
                return;
            }
            
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            // Visual feedback - find the note that matches this frequency
            const noteEntry = Object.entries(notes).find(([key, f]) => f === freq);
            if (noteEntry) {
                const [noteName] = noteEntry;
                const keyEl = document.querySelector(`[data-note="${noteName}"]`);
                if (keyEl) {
                    keyEl.classList.add('active');
                    setTimeout(() => keyEl.classList.remove('active'), 200);
                }
            }
            
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            const wave = document.getElementById('waveType').value;
            osc.type = wave;
            osc.frequency.setValueAtTime(freq, audioContext.currentTime);
            
            const now = audioContext.currentTime;
            const attack = attackTime / 1000;
            const release = releaseTime / 1000;
            
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.3, now + attack);
            gain.gain.exponentialRampToValueAtTime(0.01, now + release);
            
            osc.connect(gain);
            gain.connect(masterGain);
            
            osc.start();
            osc.stop(audioContext.currentTime + release);
            
            if (!skipRecording && (isRecording || isOverdub)) {
                loopSlots[activeSlot].loop.push({
                    type: 'synth',
                    freq: freq,
                    wave: wave,
                    time: audioContext.currentTime - recordingStart
                });
            }
        }

        // Event Listeners
        document.getElementById('initBtn').addEventListener('click', initSystem);
        
        // Mic button
        document.getElementById('micBtn').addEventListener('click', toggleMic);

        // Helper function for touch-friendly event listeners
        function addTouchClick(element, handler) {
            let touchHandled = false;
            
            element.addEventListener('touchstart', function(e) {
                e.preventDefault();
                touchHandled = true;
                handler.call(this, e);
            });
            
            element.addEventListener('click', function(e) {
                if (!touchHandled) {
                    handler.call(this, e);
                }
                touchHandled = false;
            });
        }

        document.querySelectorAll('.pad').forEach(pad => {
            addTouchClick(pad, function() {
                const sound = this.dataset.sound;
                playDrum(sound);
            });
        });

        document.querySelectorAll('.key').forEach(key => {
            addTouchClick(key, function() {
                const note = this.dataset.note;
                playNote(notes[note]);
            });
        });

        const sequencer = document.getElementById('sequencer');
        const drums = ['kick', 'snare', 'hihat', 'clap', 'tom1', 'perc', 'cymbal', 'rim'];
        
        drums.forEach(drum => {
            const stepsContainer = document.querySelector(`.seq-steps[data-drum="${drum}"]`);
            for (let i = 0; i < 16; i++) {
                const step = document.createElement('div');
                step.className = 'step';
                step.dataset.drum = drum;
                step.dataset.index = i;
                addTouchClick(step, function() {
                    sequencerSteps[drum][i] = !sequencerSteps[drum][i];
                    this.classList.toggle('active');
                    updatePatternCount();
                });
                stepsContainer.appendChild(step);
            }
        });

        document.getElementById('playSeq').addEventListener('click', toggleSequencer);

        function toggleSequencer() {
            if (!audioContext) {
                initSystem();
                setTimeout(toggleSequencer, 100);
                return;
            }
            
            if (!isPlaying) {
                isPlaying = true;
                const tempo = parseInt(document.getElementById('tempo').value);
                const interval = (60 / tempo) * 1000 / 4;
                
                document.getElementById('playSeq').textContent = 'stop';
                document.getElementById('playSeq').classList.add('active');
                
                sequencerInterval = setInterval(() => {
                    const steps = document.querySelectorAll('.step');
                    steps.forEach(s => s.classList.remove('playing'));
                    
                    // Highlight current step on all rows
                    const currentSteps = document.querySelectorAll(`.step[data-index="${currentStep}"]`);
                    currentSteps.forEach(s => s.classList.add('playing'));
                    
                    // Play all active drums for this step
                    drums.forEach(drum => {
                        if (sequencerSteps[drum][currentStep]) {
                            playDrum(drum);
                        }
                    });
                    
                    currentStep = (currentStep + 1) % 16;
                }, interval);
            } else {
                stopSequencer();
            }
        }

        function stopSequencer() {
            clearInterval(sequencerInterval);
            isPlaying = false;
            currentStep = 0;
            document.querySelectorAll('.step').forEach(s => s.classList.remove('playing'));
            document.getElementById('playSeq').textContent = 'play';
            document.getElementById('playSeq').classList.remove('active');
        }

        document.getElementById('clearSeq').addEventListener('click', () => {
            drums.forEach(drum => {
                sequencerSteps[drum] = Array(16).fill(false);
            });
            document.querySelectorAll('.step').forEach(s => s.classList.remove('active'));
            updatePatternCount();
        });

        document.getElementById('recordBtn').addEventListener('click', () => {
            if (!audioContext) {
                initSystem();
                setTimeout(() => document.getElementById('recordBtn').click(), 100);
                return;
            }
            
            if (!isRecording) {
                // Start recording (clears current slot)
                isRecording = true;
                isOverdub = false;
                recordingStart = audioContext.currentTime;
                loopSlots[activeSlot].loop = [];
                audioChunks = [];
                
                // Hide download button
                document.getElementById('downloadBtn').style.display = 'none';
                
                // Start MediaRecorder
                mediaRecorder = new MediaRecorder(mediaStreamDestination.stream);
                
                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };
                
                mediaRecorder.onstop = async () => {
                    const blob = new Blob(audioChunks, { type: 'audio/webm' });
                    loopSlots[activeSlot].audioBlob = blob;
                    
                    // Convert blob to AudioBuffer for playback
                    try {
                        const arrayBuffer = await blob.arrayBuffer();
                        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        loopSlots[activeSlot].audioBuffer = audioBuffer;
                        loopSlots[activeSlot].duration = audioBuffer.duration;
                    } catch (error) {
                        console.error('Error decoding audio:', error);
                    }
                    
                    updateSlotUI();
                    // Show download button
                    document.getElementById('downloadBtn').style.display = 'block';
                };
                
                mediaRecorder.start();
                
                document.getElementById('recordBtn').textContent = 'recording...';
                document.getElementById('recordBtn').classList.add('active');
                document.getElementById('recStatus').textContent = 'on';
            } else {
                // Stop recording
                isRecording = false;
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                }
                document.getElementById('recordBtn').textContent = 'rec';
                document.getElementById('recordBtn').classList.remove('active');
                document.getElementById('recStatus').textContent = 'off';
            }
        });

        // Overdub button - records on top of existing loop
        document.getElementById('overdubBtn').addEventListener('click', () => {
            if (!audioContext) {
                initSystem();
                setTimeout(() => document.getElementById('overdubBtn').click(), 100);
                return;
            }
            
            if (!isOverdub && !isRecording) {
                // Start overdub (keeps existing loop)
                isOverdub = true;
                recordingStart = audioContext.currentTime;
                audioChunks = [];
                
                // Hide download button
                document.getElementById('downloadBtn').style.display = 'none';
                
                // Start MediaRecorder
                mediaRecorder = new MediaRecorder(mediaStreamDestination.stream);
                
                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };
                
                mediaRecorder.onstop = async () => {
                    const blob = new Blob(audioChunks, { type: 'audio/webm' });
                    loopSlots[activeSlot].audioBlob = blob;
                    
                    // Convert blob to AudioBuffer for playback
                    try {
                        const arrayBuffer = await blob.arrayBuffer();
                        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        loopSlots[activeSlot].audioBuffer = audioBuffer;
                        loopSlots[activeSlot].duration = audioBuffer.duration;
                    } catch (error) {
                        console.error('Error decoding audio:', error);
                    }
                    
                    updateSlotUI();
                    document.getElementById('downloadBtn').style.display = 'block';
                };
                
                mediaRecorder.start();
                
                document.getElementById('overdubBtn').textContent = 'overdubbing...';
                document.getElementById('overdubBtn').classList.add('active');
                document.getElementById('recStatus').textContent = 'overdub';
            } else if (isOverdub) {
                // Stop overdub
                isOverdub = false;
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                }
                document.getElementById('overdubBtn').textContent = 'overdub';
                document.getElementById('overdubBtn').classList.remove('active');
                document.getElementById('recStatus').textContent = 'off';
            }
        });

        document.getElementById('playLoopBtn').addEventListener('click', () => {
            const slot = loopSlots[activeSlot];
            
            if (!audioContext) {
                initSystem();
                setTimeout(() => document.getElementById('playLoopBtn').click(), 100);
                return;
            }
            
            // Play recorded audio buffer if exists
            if (slot.audioBuffer) {
                const source = audioContext.createBufferSource();
                source.buffer = slot.audioBuffer;
                source.connect(masterGain);
                source.start(0);
            }
            
            // Play programmed events (drums/keys)
            if (slot.loop.length > 0) {
                slot.loop.forEach(event => {
                    setTimeout(() => {
                        if (event.type === 'drum') {
                            playDrum(event.sound, true); // skipRecording = true
                        } else if (event.type === 'synth') {
                            playNote(event.freq, true); // skipRecording = true
                        }
                    }, event.time * 1000);
                });
            }
        });

        // Play all slots simultaneously
        document.getElementById('playAllBtn').addEventListener('click', () => {
            if (!audioContext) {
                initSystem();
                setTimeout(() => document.getElementById('playAllBtn').click(), 100);
                return;
            }
            
            Object.keys(loopSlots).forEach(slotKey => {
                const slot = loopSlots[slotKey];
                
                // Play recorded audio buffer if exists
                if (slot.audioBuffer) {
                    const source = audioContext.createBufferSource();
                    source.buffer = slot.audioBuffer;
                    source.connect(masterGain);
                    source.start(0);
                }
                
                // Play programmed events (drums/keys)
                if (slot.loop.length > 0) {
                    slot.loop.forEach(event => {
                        setTimeout(() => {
                            if (event.type === 'drum') {
                                playDrum(event.sound, true); // skipRecording = true
                            } else if (event.type === 'synth') {
                                playNote(event.freq, true); // skipRecording = true
                            }
                        }, event.time * 1000);
                    });
                }
            });
        });

        document.getElementById('clearLoopBtn').addEventListener('click', () => {
            loopSlots[activeSlot].loop = [];
            loopSlots[activeSlot].audioBlob = null;
            loopSlots[activeSlot].audioBuffer = null;
            loopSlots[activeSlot].duration = 0;
            updateSlotUI();
            document.getElementById('downloadBtn').style.display = 'none';
        });

        document.getElementById('downloadBtn').addEventListener('click', () => {
            const blob = loopSlots[activeSlot].audioBlob;
            if (!blob) return;
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            a.download = `playground-mk1-slot-${activeSlot}-${timestamp}.webm`;
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        });

        // Slot selector buttons
        document.querySelectorAll('.slot-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                // Remove active class from all slots
                document.querySelectorAll('.slot-btn').forEach(b => b.classList.remove('active'));
                // Add active class to clicked slot
                this.classList.add('active');
                // Update active slot
                activeSlot = this.dataset.slot;
                // Update UI
                updateSlotUI();
            });
        });

        // Update slot UI (info text and indicators)
        function updateSlotUI() {
            const slot = loopSlots[activeSlot];
            const hasContent = slot.loop.length > 0 || slot.audioBuffer !== null;
            
            // Update slot info text
            let infoText;
            if (slot.audioBuffer) {
                const duration = slot.duration.toFixed(1);
                infoText = `slot ${activeSlot} · ${duration}s recorded`;
            } else if (slot.loop.length > 0) {
                infoText = `slot ${activeSlot} · ${slot.loop.length} events`;
            } else {
                infoText = `slot ${activeSlot} · empty`;
            }
            document.getElementById('slotInfo').textContent = infoText;
            
            // Update slot button indicators
            document.querySelectorAll('.slot-btn').forEach(btn => {
                const slotKey = btn.dataset.slot;
                const slotHasContent = loopSlots[slotKey].loop.length > 0 || loopSlots[slotKey].audioBuffer !== null;
                if (slotHasContent) {
                    btn.classList.add('has-content');
                } else {
                    btn.classList.remove('has-content');
                }
            });
            
            // Show/hide download button
            if (slot.audioBlob) {
                document.getElementById('downloadBtn').style.display = 'block';
            } else {
                document.getElementById('downloadBtn').style.display = 'none';
            }
        }

        document.getElementById('masterVol').addEventListener('input', function() {
            if (masterGain) masterGain.gain.value = this.value / 100;
            document.getElementById('masterVolVal').textContent = this.value + '%';
        });

        document.getElementById('attack').addEventListener('input', function() {
            attackTime = this.value;
            document.getElementById('attackVal').textContent = this.value + 'ms';
        });

        document.getElementById('release').addEventListener('input', function() {
            releaseTime = this.value;
            document.getElementById('releaseVal').textContent = this.value + 'ms';
        });

        document.getElementById('tempo').addEventListener('input', function() {
            document.getElementById('tempoVal').textContent = this.value;
            document.getElementById('tempoStatus').textContent = this.value;
            // If sequencer is playing, restart with new tempo
            if (isPlaying) {
                stopSequencer();
                setTimeout(() => toggleSequencer(), 50);
            }
        });

        document.getElementById('reverb').addEventListener('input', function() {
            const value = this.value / 100;
            document.getElementById('reverbVal').textContent = this.value + '%';
            if (window.reverbMix) {
                window.reverbMix.gain.value = value;
            }
        });

        document.getElementById('delay').addEventListener('input', function() {
            const value = this.value / 100;
            document.getElementById('delayVal').textContent = this.value + '%';
            if (window.delayMix) {
                window.delayMix.gain.value = value;
            }
        });

        document.getElementById('filter').addEventListener('input', function() {
            const value = parseInt(this.value);
            document.getElementById('filterVal').textContent = value + 'Hz';
            if (window.filterNode) {
                window.filterNode.frequency.setValueAtTime(value, audioContext.currentTime);
            }
        });

        // Keyboard
        const keyMap = {
            '1': 'kick', '2': 'snare', '3': 'hihat', '4': 'clap',
            '5': 'tom1', '6': 'perc', '7': 'cymbal', '8': 'rim',
            'a': 'C4', 'w': 'C#4', 's': 'D4', 'e': 'D#4',
            'd': 'E4', 'f': 'F4', 't': 'F#4', 'g': 'G4',
            'y': 'G#4', 'h': 'A4', 'u': 'A#4', 'j': 'B4', 'k': 'C5'
        };

        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            
            if (key === 'enter') {
                initSystem();
                return;
            }
            
            if (key === ' ') {
                e.preventDefault();
                toggleSequencer();
                return;
            }
            
            if (key === 'r') {
                document.getElementById('recordBtn').click();
                return;
            }
            if (key === 'o') {
                document.getElementById('overdubBtn').click();
                return;
            }
            if (key === 'p') {
                document.getElementById('playLoopBtn').click();
                return;
            }
            if (key === 'l') {
                document.getElementById('playAllBtn').click();
                return;
            }
            if (key === 'c') {
                document.getElementById('clearLoopBtn').click();
                return;
            }
            if (key === 'x') {
                document.getElementById('clearSeq').click();
                return;
            }
            if (key === 'v') {
                document.getElementById('downloadBtn').click();
                return;
            }
            if (key === 'm') {
                toggleMic();
                return;
            }
            
            // Slot selection
            if (key === 'q') {
                document.querySelector('[data-slot="A"]').click();
                return;
            }
            if (key === 'z') {
                document.querySelector('[data-slot="B"]').click();
                return;
            }
            if (key === 'b') {
                document.querySelector('[data-slot="C"]').click();
                return;
            }
            if (key === 'n') {
                document.querySelector('[data-slot="D"]').click();
                return;
            }
            
            if (keyMap[key]) {
                const val = keyMap[key];
                
                if (['kick', 'snare', 'hihat', 'clap', 'tom1', 'perc', 'cymbal', 'rim'].includes(val)) {
                    playDrum(val);
                    const pad = document.querySelector(`[data-sound="${val}"]`);
                    if (pad) {
                        pad.classList.add('active');
                        setTimeout(() => pad.classList.remove('active'), 150);
                    }
                } else {
                    playNote(notes[val]);
                    const keyEl = document.querySelector(`[data-note="${val}"]`);
                    if (keyEl) {
                        keyEl.classList.add('active');
                        setTimeout(() => keyEl.classList.remove('active'), 200);
                    }
                }
            }
        });

        // Visualizer
        function drawViz() {
            if (!isActive || !analyser) {
                requestAnimationFrame(drawViz);
                return;
            }
            
            requestAnimationFrame(drawViz);
            
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteTimeDomainData(dataArray);
            
            ctx.fillStyle = '#fafafa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#000';
            ctx.beginPath();
            
            const sliceWidth = canvas.width / bufferLength;
            let x = 0;
            
            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0;
                const y = v * canvas.height / 2;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
                
                x += sliceWidth;
            }
            
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();
        }

        // Responsive canvas resize with debouncing
        let resizeTimeout;
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(resizeCanvas, 100);
        });
        
        // Handle orientation change on mobile
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvas, 300);
        });

        // Timestamp display
        function updateTimestamp() {
            const now = new Date();
            const date = now.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' });
            const time = now.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            document.getElementById('timestamp').textContent = `${date} — ${time}`;
        }
        
        updateTimestamp();
        setInterval(updateTimestamp, 1000);

        // Pattern counter
        function updatePatternCount() {
            let totalActive = 0;
            drums.forEach(drum => {
                const activeSteps = sequencerSteps[drum].filter(step => step).length;
                totalActive += activeSteps;
            });
            document.getElementById('patternCount').textContent = totalActive > 0 ? 1 : 0;
        }

        // Load Demo - creates a musical example
        document.getElementById('loadDemoBtn').addEventListener('click', () => {
            if (!audioContext) {
                initSystem();
            }
            
            // Clear everything first
            Object.keys(loopSlots).forEach(key => {
                loopSlots[key].loop = [];
                loopSlots[key].audioBlob = null;
                loopSlots[key].audioBuffer = null;
                loopSlots[key].duration = 0;
            });
            drums.forEach(drum => {
                sequencerSteps[drum] = Array(16).fill(false);
            });
            
            // Load Pattern - Basic house beat
            // Kick on 1, 5, 9, 13 (four on the floor)
            sequencerSteps.kick[0] = true;
            sequencerSteps.kick[4] = true;
            sequencerSteps.kick[8] = true;
            sequencerSteps.kick[12] = true;
            
            // Snare on 4, 12 (backbeat)
            sequencerSteps.snare[4] = true;
            sequencerSteps.snare[12] = true;
            
            // Hi-hat every other step (16th notes)
            for (let i = 0; i < 16; i += 2) {
                sequencerSteps.hihat[i] = true;
            }
            
            // Clap on 4, 12 (with snare)
            sequencerSteps.clap[4] = true;
            sequencerSteps.clap[12] = true;
            
            // Update visual
            document.querySelectorAll('.step').forEach(step => {
                const drum = step.dataset.drum;
                const index = parseInt(step.dataset.index);
                if (sequencerSteps[drum][index]) {
                    step.classList.add('active');
                } else {
                    step.classList.remove('active');
                }
            });
            
            // Load Loop A - Simple melody
            activeSlot = 'A';
            document.querySelectorAll('.slot-btn').forEach(b => b.classList.remove('active'));
            document.querySelector('[data-slot="A"]').classList.add('active');
            
            // Create a simple melodic loop (C major scale)
            loopSlots.A.loop = [
                { type: 'synth', freq: notes.C4, wave: 'sine', time: 0 },
                { type: 'synth', freq: notes.E4, wave: 'sine', time: 0.5 },
                { type: 'synth', freq: notes.G4, wave: 'sine', time: 1.0 },
                { type: 'synth', freq: notes.C5, wave: 'sine', time: 1.5 },
                { type: 'synth', freq: notes.G4, wave: 'sine', time: 2.0 },
                { type: 'synth', freq: notes.E4, wave: 'sine', time: 2.5 },
                { type: 'synth', freq: notes.C4, wave: 'sine', time: 3.0 }
            ];
            
            // Set tempo to 120 (default)
            document.getElementById('tempo').value = 120;
            document.getElementById('tempoVal').textContent = '120';
            document.getElementById('tempoStatus').textContent = '120';
            
            // Set wave to sine for melodic sound
            document.getElementById('waveType').value = 'sine';
            
            // Update UI
            updatePatternCount();
            updateSlotUI();
            
            // Show message
            const heroP = document.querySelector('.hero p');
            const originalText = heroP.textContent;
            heroP.textContent = 'demo loaded! press space to play pattern or P to play loop';
            setTimeout(() => {
                heroP.textContent = originalText;
            }, 4000);
        });

        // Clear All - resets everything to initial state
        document.getElementById('clearAllBtn').addEventListener('click', () => {
            // Turn off mic if active
            if (isMicActive) {
                toggleMic();
            }
            
            // Clear all loop slots
            Object.keys(loopSlots).forEach(key => {
                loopSlots[key].loop = [];
                loopSlots[key].audioBlob = null;
                loopSlots[key].audioBuffer = null;
                loopSlots[key].duration = 0;
                loopSlots[key].isPlaying = false;
            });
            
            // Clear all sequencer patterns
            drums.forEach(drum => {
                sequencerSteps[drum] = Array(16).fill(false);
            });
            
            // Update visual for sequencer
            document.querySelectorAll('.step').forEach(step => {
                step.classList.remove('active');
            });
            
            // Stop sequencer if playing
            if (isPlaying) {
                stopSequencer();
            }
            
            // Reset to slot A
            activeSlot = 'A';
            document.querySelectorAll('.slot-btn').forEach(b => b.classList.remove('active'));
            document.querySelector('[data-slot="A"]').classList.add('active');
            
            // Reset controls to defaults
            document.getElementById('tempo').value = 120;
            document.getElementById('tempoVal').textContent = '120';
            document.getElementById('tempoStatus').textContent = '120';
            
            document.getElementById('waveType').value = 'sine';
            
            document.getElementById('attack').value = 10;
            document.getElementById('attackVal').textContent = '10ms';
            
            document.getElementById('release').value = 300;
            document.getElementById('releaseVal').textContent = '300ms';
            
            document.getElementById('reverb').value = 40;
            document.getElementById('reverbVal').textContent = '40%';
            if (window.reverbMix) window.reverbMix.gain.value = 0.4;
            
            document.getElementById('delay').value = 20;
            document.getElementById('delayVal').textContent = '20%';
            if (window.delayMix) window.delayMix.gain.value = 0.2;
            
            document.getElementById('filter').value = 8000;
            document.getElementById('filterVal').textContent = '8000Hz';
            if (window.filterNode) window.filterNode.frequency.value = 8000;
            
            document.getElementById('masterVol').value = 70;
            document.getElementById('masterVolVal').textContent = '70%';
            if (masterGain) masterGain.gain.value = 0.7;
            
            // Hide download button
            document.getElementById('downloadBtn').style.display = 'none';
            
            // Update UI
            updatePatternCount();
            updateSlotUI();
            
            // Show message
            const heroP = document.querySelector('.hero p');
            const originalText = heroP.textContent;
            heroP.textContent = 'everything cleared! ready to create';
            setTimeout(() => {
                heroP.textContent = originalText;
            }, 3000);
        });
    </script>
</body>
</html>
